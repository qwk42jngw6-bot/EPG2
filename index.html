<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TV Programm</title>
  <style>
    :root{
      --bg:#0f1419; --card:#1e293b; --muted:#94a3b8; --line:#334155; --text:#e2e8f0;
      --gold:#f5c518; --red:#dc2626; --green:#16a34a; --blue:#3b82f6;
    }
    *{box-sizing:border-box;margin:0;padding:0}
    body{background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial,sans-serif;line-height:1.45;padding:16px}
    .container{max-width:1200px;margin:0 auto}
    header{display:flex;gap:12px;align-items:center;justify-content:space-between;margin-bottom:16px;padding-bottom:12px;border-bottom:1px solid var(--line)}
    h1{font-size:20px;font-weight:700}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    button,select{
      background:#0b1220;border:1px solid var(--line);color:var(--text);
      padding:8px 10px;border-radius:8px;cursor:pointer;font-size:14px
    }
    button:hover,select:hover{border-color:#475569}
    .timestamp{color:var(--muted);font-size:12px}
    .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(300px,1fr));gap:12px}
    .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:12px}
    .head{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
    .ch-name{font-weight:600}
    .ch-no{font-size:12px;color:#60a5fa}
    .now{margin:8px 0}
    .title{font-size:14px}
    .time{font-size:12px;color:var(--muted)}
    .next .item{display:flex;justify-content:space-between;font-size:12px;color:var(--muted);margin-top:6px}
    .badges{margin-top:8px;display:flex;flex-wrap:wrap;gap:6px}
    .badge{font-size:10px;padding:3px 6px;border-radius:6px}
    .b-imdb{background:var(--gold);color:#000}
    .b-rtu{background:var(--green);color:#fff}
    .b-rtc{background:var(--red);color:#fff}
    .b-gpt{background:var(--blue);color:#fff}
    .error{background:#7f1d1d;border:1px solid var(--red);color:#fca5a5;padding:12px;border-radius:8px;margin:10px 0}
    .source{margin-top:6px;color:var(--muted);font-size:10px}
    .statusbar{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0}
    .pill{font-size:12px;padding:4px 8px;border:1px solid var(--line);border-radius:999px}
  </style>
</head>
<body>
<div class="container">
  <header>
    <div>
      <h1>TV Programm</h1>
      <div class="timestamp" id="ts">–</div>
    </div>
    <div class="controls">
      <select id="sourceSet">
        <option value="de">Quelle: DE (auto)</option>
        <option value="single">Quelle: Single-Set</option>
        <option value="alt">Quelle: Alternativ</option>
      </select>
      <button id="refresh">Aktualisieren</button>
      <button id="scan">Quellen prüfen</button>
    </div>
  </header>

  <div id="status" class="statusbar"></div>
  <div id="errors"></div>
  <div id="grid" class="grid"></div>
</div>

<script>
  // === Konfiguration ===
  const WORKER = "https://waterfall-epg.w2gy9ymm7y.workers.dev"; // <- dein Worker
  const MAX_NEXT = 2; // nur die nächsten 2 anzeigen
  const ratingCache = new Map(); // einfache Laufzeit-Cache pro Titel

  const sourceSetEl = document.getElementById('sourceSet');
  const grid = document.getElementById('grid');
  const ts = document.getElementById('ts');
  const errors = document.getElementById('errors');
  const statusbar = document.getElementById('status');

  document.getElementById('refresh').addEventListener('click', loadNow);
  document.getElementById('scan').addEventListener('click', doScan);
  sourceSetEl.addEventListener('change', loadNow);

  loadNow(); // Initial

  async function loadNow(){
    showError(); // clear
    setStatus();
    grid.innerHTML = "<div class='pill'>Lade EPG…</div>";
    try{
      const set = sourceSetEl.value;
      const r = await fetch(`${WORKER}/api/now?set=${encodeURIComponent(set)}`);
      if(!r.ok) throw new Error(`HTTP ${r.status}`);
      const data = await r.json();

      ts.textContent = data.ts ? fmtDateTime(data.ts) : "–";
      setStatus(data);
      renderGrid(data.items||[], data.sourceUsed||"");
    }catch(e){
      showError("Ladefehler", e.message || String(e));
      grid.innerHTML = "";
    }
  }

  function setStatus(data){
    statusbar.innerHTML = "";
    if(!data) return;
    if (data.sourceUsed){
      addPill(`Quelle: ${shortSource(data.sourceUsed)}`);
    }
    if (Array.isArray(data.attempts)){
      const ok = data.attempts.find(a => a.ok);
      const bad = data.attempts.filter(a => a.ok===false);
      if (ok) addPill("OK: 1");
      if (bad.length) addPill(`Fehler: ${bad.length}`);
    }
  }
  function addPill(t){ const s=document.createElement('span');s.className='pill';s.textContent=t;statusbar.appendChild(s); }
  function shortSource(u){
    if(!u) return "";
    try{
      const p = new URL(u);
      return p.hostname.replace(/^www\./,'') + (p.pathname!=="/"?p.pathname:"");
    }catch{ return u; }
  }

  function renderGrid(items, sourceUsed){
    if(!items || !items.length){
      grid.innerHTML = "<div class='error'>Keine Senderdaten</div>";
      return;
    }
    const html = items.map(ch => {
      const now = ch.now ? `
        <div class="now">
          <div class="title">${esc(ch.now.title)}</div>
          <div class="time">${fmtTime(ch.now.start)} – ${fmtTime(ch.now.stop)}</div>
          ${ratingsBlock(ch.now.title)}
        </div>
      ` : `<div class="now"><div class="time">Aktuell: –</div></div>`;

      const nextArr = (ch.next||[]).slice(0, MAX_NEXT);
      const next = nextArr.length ? `
        <div class="next">
          ${nextArr.map(n => `
            <div class="item">
              <span>${esc(n.title)}</span>
              <span>${fmtTime(n.start)}</span>
            </div>
            ${ratingsBlock(n.title)}
          `).join("")}
        </div>
      ` : "";

      return `
        <div class="card">
          <div class="head">
            <div class="ch-name">${esc(ch.channel)}</div>
            <div class="ch-no">#${ch.no}</div>
          </div>
          ${now}
          ${next}
          <div class="source">${esc(shortSource(sourceUsed))}</div>
        </div>
      `;
    }).join("");
    grid.innerHTML = html;
    // Lazy Ratings laden (dedup)
    collectAndFetchRatings();
  }

  function ratingsBlock(title){
    const key = (title||"").trim();
    if(!key) return "";
    const cached = ratingCache.get(key);
    const imdb = cached?.imdb, rtu=cached?.rtUser, rtc=cached?.rtCritic, gpt=cached?.gpt;
    return `
      <div class="badges" data-title="${escAttr(key)}">
        ${imdb!=null ? `<span class="badge b-imdb">IMDb ${num(imdb)}</span>`:""}
        ${rtu!=null  ? `<span class="badge b-rtu">RT ${rtu}%</span>`:""}
        ${rtc!=null  ? `<span class="badge b-rtc">RT ${rtc}%</span>`:""}
        ${gpt!=null  ? `<span class="badge b-gpt">AI ${num(gpt)}/10</span>`:""}
      </div>
    `;
  }

  function collectAndFetchRatings(){
    const blocks = [...document.querySelectorAll('.badges[data-title]')];
    const titles = [...new Set(blocks.map(b => b.getAttribute('data-title')).filter(Boolean))];

    // nur Titel ohne Cache anfragen
    const toFetch = titles.filter(t => !ratingCache.has(t));
    if (!toFetch.length) return;

    // nacheinander (OMDb-Rate-Limit schonend)
    (async ()=>{
      for (const t of toFetch) {
        try{
          const r = await fetch(`${WORKER}/api/ratings?title=${encodeURIComponent(t)}`);
          if(!r.ok) throw new Error(`HTTP ${r.status}`);
          const data = await r.json();
          if (data && data.ratings){
            ratingCache.set(t, data.ratings);
            // Update alle Blocks dieses Titels
            document.querySelectorAll(`.badges[data-title="${cssSel(t)}"]`).forEach(node=>{
              node.innerHTML = `
                ${data.ratings.imdb!=null ? `<span class="badge b-imdb">IMDb ${num(data.ratings.imdb)}</span>`:""}
                ${data.ratings.rtUser!=null ? `<span class="badge b-rtu">RT ${data.ratings.rtUser}%</span>`:""}
                ${data.ratings.rtCritic!=null ? `<span class="badge b-rtc">RT ${data.ratings.rtCritic}%</span>`:""}
                ${data.ratings.gpt!=null ? `<span class="badge b-gpt">AI ${num(data.ratings.gpt)}/10</span>`:""}
              `;
            });
          }
        }catch(e){
          // still fine – einfach keine Badges
          ratingCache.set(t, {});
        }
        await sleep(250); // kleine Pause
      }
    })();
  }

  async function doScan(){
    showError();
    try{
      const set = sourceSetEl.value;
      const r = await fetch(`${WORKER}/api/debug-scan?set=${encodeURIComponent(set)}`);
      if(!r.ok) throw new Error(`HTTP ${r.status}`);
      const data = await r.json();
      const lines = (data.results||[]).map(o =>
        `${o.i}. ${o.url}\n   → ${o.status} · ${o.ct||""} · ${o.len||""}\n   ${o.bodySample||""}`
      ).join("\n\n");
      showError("Debug Scan", lines || (data.note||"keine Ergebnisse"));
    }catch(e){
      showError("Scan-Fehler", e.message || String(e));
    }
  }

  // === Helpers ===
  function esc(s){ return (s||"").replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
  function escAttr(s){ return esc(s); }
  function cssSel(s){ return s.replace(/["\\]/g, "\\$&"); }
  function fmtTime(iso){ const d = new Date(iso); return d.toLocaleTimeString('de-DE',{hour:'2-digit',minute:'2-digit'}); }
  function fmtDateTime(iso){ const d = new Date(iso); return d.toLocaleString('de-DE',{hour:'2-digit',minute:'2-digit',second:'2-digit'}); }
  function showError(title, msg){
    if(!title){ errors.innerHTML=""; return; }
    errors.innerHTML = `<div class="error"><strong>${esc(title)}</strong><br>${msg ? esc(msg).replace(/\n/g,"<br>"):""}</div>`;
  }
  function num(n){ return (typeof n==="number") ? (Math.round(n*10)/10).toString() : n; }
  const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
</script>
</body>
</html>
